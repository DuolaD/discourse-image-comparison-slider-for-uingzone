<script defer>
  (() => {
    "use strict";
    // 样式模块定义
    var t = {
        792: (t, e, i) => {
          i.d(e, {
            Z: () => n,
          });
          var s = i(609),
            o = i.n(s)()(function (t) {
              return t[1];
            });
          // 定义组件的CSS样式
          o.push([
            t.id,
            ':host{--divider-width: 1px;--divider-color: #fff;--divider-shadow: none;--default-handle-width: 50px;--default-handle-color: #fff;--default-handle-opacity: 1;--default-handle-shadow: none;--handle-position-start: 50%;position:relative;display:inline-block;overflow:hidden;line-height:0;direction:ltr}@media screen and (-webkit-min-device-pixel-ratio: 0)and (min-resolution: 0.001dpcm){:host{outline-offset:1px}}::slotted(*){-webkit-user-drag:none;-khtml-user-drag:none;-moz-user-drag:none;-o-user-drag:none;user-drag:none;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.first{position:absolute;left:0;top:0;right:0;line-height:normal;font-size:100%;max-height:100%;height:100%;width:100%;--exposure: 50%;--keyboard-transition-time: 0ms;--default-transition-time: 0ms;--transition-time: var(--default-transition-time)}.first .first-overlay-container{position:relative;clip-path:inset(0 var(--exposure) 0 0);transition:clip-path var(--transition-time);height:100%}.first .first-overlay{overflow:hidden;height:100%}.first.focused{will-change:clip-path}.first.focused .first-overlay-container{will-change:clip-path}.second{position:relative}.handle-container{transform:translateX(50%);position:absolute;top:0;right:var(--exposure);height:100%;transition:right var(--transition-time),bottom var(--transition-time)}.focused .handle-container{will-change:right}.divider{position:absolute;height:100%;width:100%;left:0;top:0;display:flex;align-items:center;justify-content:center;flex-direction:column}.divider:after{content:" ";display:block;height:100%;border-left-width:var(--divider-width);border-left-style:solid;border-left-color:var(--divider-color);box-shadow:var(--divider-shadow)}.handle{position:absolute;top:var(--handle-position-start);box-sizing:border-box;margin-left:1px;transform:translate(calc(-50% - 0.5px), -50%);line-height:0}.default-handle{width:var(--default-handle-width);opacity:var(--default-handle-opacity);transition:all 1s;filter:drop-shadow(var(--default-handle-shadow))}.default-handle path{stroke:var(--default-handle-color)}.vertical .first-overlay-container{clip-path:inset(0 0 var(--exposure) 0)}.vertical .handle-container{transform:translateY(50%);height:auto;top:unset;bottom:var(--exposure);width:100%;left:0;flex-direction:row}.vertical .divider:after{height:1px;width:100%;border-top-width:var(--divider-width);border-top-style:solid;border-top-color:var(--divider-color);border-left:0}.vertical .handle{top:auto;left:var(--handle-position-start);transform:translate(calc(-50% - 0.5px), -50%) rotate(90deg)}',
            "",
          ]);
          const n = o;
        },
        // CSS样式处理模块
        609: (t) => {
          t.exports = function (t) {
            var e = [];
            return (
              (e.toString = function () {
                return this.map(function (e) {
                  var i = t(e);
                  return e[2] ? "@media ".concat(e[2], " {").concat(i, "}") : i;
                }).join("");
              }),
              (e.i = function (t, i, s) {
                "string" == typeof t && (t = [[null, t, ""]]);
                var o = {};
                if (s)
                  for (var n = 0; n < this.length; n++) {
                    var r = this[n][0];
                    null != r && (o[r] = !0);
                  }
                for (var a = 0; a < t.length; a++) {
                  var d = [].concat(t[a]);
                  (s && o[d[0]]) ||
                    (i &&
                      (d[2]
                        ? (d[2] = "".concat(i, " and ").concat(d[2]))
                        : (d[2] = i)),
                    e.push(d));
                }
              }),
              e
            );
          };
        },
      },
      e = {};

    // 模块加载器
    function i(s) {
      var o = e[s];
      if (void 0 !== o) return o.exports;
      var n = (e[s] = {
        id: s,
        exports: {},
      });
      return t[s](n, n.exports, i), n.exports;
    }
    (i.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return (
        i.d(e, {
          a: e,
        }),
        e
      );
    }),
      (i.d = (t, e) => {
        for (var s in e)
          i.o(e, s) &&
            !i.o(t, s) &&
            Object.defineProperty(t, s, {
              enumerable: !0,
              get: e[s],
            });
      }),
      (i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
      (() => {
        var t = i(792);
        const e = "rendered",
          // 检查点击是否在元素范围内
          s = (t, e) => {
            const i = t.getBoundingClientRect();
            let s, o;
            return (
              "mousedown" === e.type
                ? ((s = e.clientX), (o = e.clientY))
                : ((s = e.touches[0].clientX), (o = e.touches[0].clientY)),
              s >= i.x && s <= i.x + i.width && o >= i.y && o <= i.y + i.height
            );
          },
          // 创建组件模板
          o = document.createElement("template");
        o.innerHTML =
          '<div class="second" id="second"> <slot name="second"><slot name="before"></slot></slot> </div> <div class="first" id="first"> <div class="first-overlay"> <div class="first-overlay-container" id="firstImageContainer"> <slot name="first"><slot name="after"></slot></slot> </div> </div> <div class="handle-container"> <div class="divider"></div> <div class="handle" id="handle"> <slot name="handle"> <svg xmlns="http://www.w3.org/2000/svg" class="default-handle" viewBox="-8 -3 16 6"> <path d="M -5 -2 L -7 0 L -5 2 M 5 -2 L 7 0 L 5 2" fill="none" vector-effect="non-scaling-stroke"/> </svg> </slot> </div> </div> </div>  <div class="all-imgs" id="all-imgs" style="display: none;"><slot name="all-imgs"></slot></div>';
        // 键盘控制常量
        const n = {
            ArrowLeft: -1,
            ArrowRight: 1,
          },
          r = ["horizontal", "vertical"],
          // 触摸事件坐标转换
          a = (t) => ({
            x: t.touches[0].pageX,
            y: t.touches[0].pageY,
          }),
          d = (t) => ({
            x: t.pageX,
            y: t.pageY,
          });
        // 图片比较滑块组件类
        class h extends HTMLElement {
          constructor() {
            super();
            // 初始化组件属性
            this.exposure = this.hasAttribute("value")
              ? parseFloat(this.getAttribute("value"))
              : 50;
            this.slideOnHover = !1;
            this.slideDirection = "horizontal";
            this.keyboard = "enabled";
            this.isMouseDown = !1;
            this.animationDirection = 0;
            this.isFocused = !1;
            this.handle = !1;

            // 鼠标双击事件
            this.onMouseDoubleClick = (t) => {
              console.log("鼠标双击事件");
              // 调用changeImageIndex更新图片
              window.changeImageIndex();
            };

            // 鼠标移动事件处理
            this.onMouseMove = (t) => {
              if (this.isMouseDown || this.slideOnHover) {
                const e = d(t);
                this.slideToPage(e);
              }
            };

            // 鼠标按下事件处理
            this.onMouseDown = (t) => {
              if (this.slideOnHover) return;
              if (this.handle && !s(this.handleElement, t)) return;
              t.preventDefault();
              window.addEventListener("mousemove", this.onMouseMove);
              window.addEventListener("mouseup", this.onWindowMouseUp);
              this.isMouseDown = !0;
              this.enableTransition();
              const e = d(t);
              this.slideToPage(e);
              this.focus();
              this.bodyUserSelectStyle = window.document.body.style.userSelect;
              window.document.body.style.userSelect = "none";
            };

            // 鼠标释放事件处理
            this.onWindowMouseUp = () => {
              this.isMouseDown = !1;
              window.document.body.style.userSelect = this.bodyUserSelectStyle;
              window.removeEventListener("mousemove", this.onMouseMove);
              window.removeEventListener("mouseup", this.onWindowMouseUp);
            };

            // 触摸事件相关属性
            this.touchStartPoint = null;
            this.isTouchComparing = !1;
            this.hasTouchMoved = !1;

            // 触摸开始事件处理
            this.onTouchStart = (t) => {
              (this.handle && !s(this.handleElement, t)) ||
                ((this.touchStartPoint = a(t)),
                this.isFocused &&
                  (this.enableTransition(),
                  this.slideToPage(this.touchStartPoint)));
            };

            // 触摸移动事件处理
            this.onTouchMove = (t) => {
              if (null === this.touchStartPoint) return;
              const e = a(t);
              if (this.isTouchComparing)
                return this.slideToPage(e), t.preventDefault(), !1;
              if (!this.hasTouchMoved) {
                const i = Math.abs(e.y - this.touchStartPoint.y),
                  s = Math.abs(e.x - this.touchStartPoint.x);
                if (
                  ("horizontal" === this.slideDirection && i < s) ||
                  ("vertical" === this.slideDirection && i > s)
                )
                  return (
                    (this.isTouchComparing = !0),
                    this.focus(),
                    this.slideToPage(e),
                    t.preventDefault(),
                    !1
                  );
                this.hasTouchMoved = !0;
              }
            };

            // 触摸结束事件处理
            this.onTouchEnd = () => {
              this.isTouchComparing = !1;
              this.hasTouchMoved = !1;
              this.touchStartPoint = null;
            };

            // 失去焦点事件处理
            this.onBlur = () => {
              this.stopSlideAnimation();
              this.isFocused = !1;
              this.firstElement.classList.remove("focused");
            };

            // 获得焦点事件处理
            this.onFocus = () => {
              this.isFocused = !0;
              this.firstElement.classList.add("focused");
            };

            // 键盘按下事件处理
            this.onKeyDown = (t) => {
              if ("disabled" === this.keyboard) return;
              const e = n[t.key];
              this.animationDirection !== e &&
                void 0 !== e &&
                ((this.animationDirection = e), this.startSlideAnimation());
            };

            // 键盘释放事件处理
            this.onKeyUp = (t) => {
              if ("disabled" === this.keyboard) return;
              const e = n[t.key];
              void 0 !== e &&
                this.animationDirection === e &&
                this.stopSlideAnimation();
            };

            // 重置尺寸
            this.resetDimensions = () => {
              this.imageWidth = this.offsetWidth;
              this.imageHeight = this.offsetHeight;
            };

            // 创建Shadow DOM
            const e = this.attachShadow({
                mode: "open",
              }),
              i = document.createElement("style");
            i.innerHTML = t.Z;
            this.getAttribute("nonce") &&
              i.setAttribute("nonce", this.getAttribute("nonce"));
            e.appendChild(i);
            e.appendChild(o.content.cloneNode(!0));
            this.firstElement = e.getElementById("first");
            this.secondElement = e.getElementById("second");
            this.handleElement = e.getElementById("handle");
            this.allImgsElement = e.getElementById("all-imgs");
          }

          // 获取和设置属性
          get value() {
            return this.exposure;
          }
          set value(t) {
            const e = parseFloat(t);
            e !== this.exposure &&
              ((this.exposure = e),
              this.enableTransition(),
              this.setExposure());
          }
          get hover() {
            return this.slideOnHover;
          }
          set hover(t) {
            this.slideOnHover = "false" !== t.toString().toLowerCase();
            this.removeEventListener("mousemove", this.onMouseMove);
            this.slideOnHover &&
              this.addEventListener("mousemove", this.onMouseMove);
          }
          get direction() {
            return this.slideDirection;
          }
          set direction(t) {
            this.slideDirection = t.toString().toLowerCase();
            this.slide(0);
            this.firstElement.classList.remove(...r);
            r.includes(this.slideDirection) &&
              this.firstElement.classList.add(this.slideDirection);
          }

          // 观察的属性
          static get observedAttributes() {
            return ["hover", "direction"];
          }

          // 组件连接回调
          connectedCallback() {
            this.hasAttribute("tabindex") || (this.tabIndex = 0);
            this.addEventListener("dragstart", (t) => (t.preventDefault(), !1));
            this.addEventListener("dblclick", this.onMouseDoubleClick);
            new ResizeObserver(this.resetDimensions).observe(this);
            this.setExposure(0);
            this.keyboard =
              this.hasAttribute("keyboard") &&
              "disabled" === this.getAttribute("keyboard")
                ? "disabled"
                : "enabled";
            this.addEventListener("keydown", this.onKeyDown);
            this.addEventListener("keyup", this.onKeyUp);
            this.addEventListener("focus", this.onFocus);
            this.addEventListener("blur", this.onBlur);
            this.addEventListener("touchstart", this.onTouchStart, {
              passive: !0,
            });
            this.addEventListener("touchmove", this.onTouchMove, {
              passive: !1,
            });
            this.addEventListener("touchend", this.onTouchEnd);
            this.addEventListener("mousedown", this.onMouseDown);
            this.handle = this.hasAttribute("handle");
            this.hover =
              !!this.hasAttribute("hover") && this.getAttribute("hover");
            this.direction = this.hasAttribute("direction")
              ? this.getAttribute("direction")
              : "horizontal";
            this.resetDimensions();
            this.classList.contains(e) || this.classList.add(e);
            this.querySelectorAll('[slot="before"], [slot="after"]').length >
              0 &&
              console.warn(
                '<img-comparison-slider>: slot names "before" and "after" are deprecated and soon won\'t be supported. Please use slot="first" instead of slot="after", and slot="second" instead of slot="before".'
              );
          }

          // 组件断开连接回调
          disconnectedCallback() {
            this.transitionTimer && window.clearTimeout(this.transitionTimer);
          }

          // 属性变化回调
          attributeChangedCallback(t, e, i) {
            "hover" === t && (this.hover = i);
            "direction" === t && (this.direction = i);
            "keyboard" === t &&
              (this.keyboard = "disabled" === i ? "disabled" : "enabled");
          }

          // 设置曝光度
          setExposure(t = 0) {
            var e;
            this.exposure =
              (100, (e = this.exposure + t) < 0 ? 0 : e > 100 ? 100 : e);
            this.firstElement.style.setProperty(
              "--exposure",
              100 - this.exposure + "%"
            );
          }

          // 滑动
          slide(t = 0) {
            this.setExposure(t);
            const e = new Event("slide");
            this.dispatchEvent(e);
          }

          // 滑动到指定位置
          slideToPage(t) {
            "horizontal" === this.slideDirection && this.slideToPageX(t.x);
            "vertical" === this.slideDirection && this.slideToPageY(t.y);
          }

          // 水平滑动
          slideToPageX(t) {
            const e = t - this.getBoundingClientRect().left - window.scrollX;
            this.exposure = (e / this.imageWidth) * 100;
            this.slide(0);
          }

          // 垂直滑动
          slideToPageY(t) {
            const e = t - this.getBoundingClientRect().top - window.scrollY;
            this.exposure = (e / this.imageHeight) * 100;
            this.slide(0);
          }

          // 启用过渡动画
          enableTransition() {
            this.firstElement.style.setProperty("--transition-time", "100ms");
            this.transitionTimer = window.setTimeout(() => {
              this.firstElement.style.setProperty(
                "--transition-time",
                "var(--default-transition-time)"
              );
              this.transitionTimer = null;
            }, 100);
          }

          // 开始滑动动画
          startSlideAnimation() {
            let t = null,
              e = this.animationDirection;
            this.firstElement.style.setProperty(
              "--transition-time",
              "var(--keyboard-transition-time)"
            );
            const i = (s) => {
              if (
                0 === this.animationDirection ||
                e !== this.animationDirection
              )
                return;
              null === t && (t = s);
              const o =
                ((s - t) / 16.666666666666668) * this.animationDirection;
              this.slide(o);
              setTimeout(() => window.requestAnimationFrame(i), 0);
              t = s;
            };
            window.requestAnimationFrame(i);
          }

          // 停止滑动动画
          stopSlideAnimation() {
            this.animationDirection = 0;
            this.firstElement.style.setProperty(
              "--transition-time",
              "var(--default-transition-time)"
            );
          }
        }
        // 注册自定义元素
        "undefined" != typeof window &&
          window.customElements.define("img-comparison-slider", h);
      })();
  })();
</script>

<style>
  img-comparison-slider {
    visibility: hidden;
  }

  img-comparison-slider [slot="second"] {
    display: none;
  }

  img-comparison-slider.rendered {
    visibility: inherit;
  }

  img-comparison-slider.rendered [slot="second"] {
    display: unset;
  }
</style>
<!-- <script version="0.0.1"> -->
<script type="text/discourse-plugin" version="0.0.1">

  let allImgLength = 0;

  // 将函数定义在window对象上，使其全局可访问
  window.changeImageIndex = function () {
    // 索引验证通过，更新全局变量
    if (window.imgIndex2 >= allImgLength) {
      window.imgIndex1 = 0;
      window.imgIndex2 = 1;
    } else {
      window.imgIndex1++;
      window.imgIndex2++;
    }
    // 重新渲染图片比较滑块
    // TODO 目前一个页面中只能有一个图片比较滑块，后续需要优化
    document.querySelectorAll('div[data-image-comparison-slider]').forEach(slider => {
      let imgs = extractImages(slider);
      let finalHTML = stackImages(imgs, settings.default_direction);
      slider.innerHTML = finalHTML;
    });
  }

  // 提取页面中的图片地址，返回图片src数组
  function extractImages(html) {]
    if (html.querySelector(".all-imgs-container")) {
      imgs = html.querySelectorAll(".all-imgs-container img");
    } else {
      imgs = html.querySelectorAll("img");
    }
    if (imgs.length == 0) {
      return ["No image found", "No image found"]
    }
    allImgLength = [...imgs].length;
    if (length > 0) {
      let imgsSrcList = []
      imgs.forEach(i => {
        imgsSrcList.push(i.src)
      })
      return imgsSrcList;
    }
    else {
      return ["No image found", "No image found"]
    }
  }

  // 根据图片数组和方向，生成图片对比滑块组件的HTML结构
  function stackImages(imgs, d) {
    if(window.imgIndex1 == undefined){
      window.imgIndex1 = 0;
      window.imgIndex2 = 1;
    }
    var left = ["<img slot='first' src='", imgs[window.imgIndex1], "'/>"].join('');
    var right = ["<img slot='second' src='", imgs[window.imgIndex2], "'/>"].join('');

    // 图片全集容器
    var allImgContaier = "";
    if (imgs.length > 2) {
      var allImgHTMLText = "";
      imgs.forEach(img => {
        allImgHTMLText = allImgHTMLText + ["<img src='", img, "'/>"].join('');
      });
      allImgContaier = ["<div slot='all-imgs' class='all-imgs-container' style='display: none;'>", allImgHTMLText, "</div>"].join('');
    }
    var direction = d;
    if (settings.handle_arrow_style == "solid") {
      right = right + '<svg slot="handle" class = "grab-handle" style = "cursor:grab" xmlns="http://www.w3.org/2000/svg" width="70" viewBox="-8 -3 16 6"><path stroke="#000" d="M -5 -2 L -7 0 L -5 2 M -5 -2 L -5 2 M 5 -2 L 7 0 L 5 2 M 5 -2 L 5 2" stroke-width="1" fill="#fff" vector-effect="non-scaling-stroke"></path></svg>'
    }
    return ["<img-comparison-slider class = 'colored-slider' direction = '", direction, "'>",
      left,
      right,
      allImgContaier,
      "</img-comparison-slider>"].join('')
  }


  function componentPrep(cooked) {
    cooked.querySelectorAll('div[data-image-comparison-slider]').forEach(slider => {
      let imgs = extractImages(slider);
      let finalHTML = stackImages(imgs, settings.default_direction);
      slider.innerHTML = finalHTML;
    })
    cooked.querySelectorAll('div[data-image-comparison-slider][data-direction-horizontal]').forEach(slider => {
      let imgs = extractImages(slider);
      let finalHTML = stackImages(imgs, "horizontal");
      slider.innerHTML = finalHTML;
    })
    cooked.querySelectorAll('div[data-image-comparison-slider][data-direction-vertical]').forEach(slider => {
      let imgs = extractImages(slider);
      let finalHTML = stackImages(imgs, "vertical");
      slider.innerHTML = finalHTML;
    })

  }


  let translations = I18n.translations[I18n.currentLocale()].js;

  if (!translations) {
    translations = {};
  }
  if (!translations.composer) {
    translations.composer = {};
  }
  translations.button_text = settings.button_text;
  translations.composer.add_images_prompt =
    settings.add_images_prompt;


  api.decorateCookedElement(componentPrep, {
    onlyStream: false,
    id: 'image-comparison-slider'
  });


  api.onToolbarCreate(function (toolbar) {
    toolbar.addButton({
      trimLeading: true,
      id: "image-comparison-slider",
      group: "insertions",
      icon: settings.button_icon,
      title: "button_text",
      perform: e => {
        e.applySurround(
          ["<div data-image-comparison-slider data-direction-", settings.default_direction, ">\n"].join(''),
          "\n\n</div>",
          "add_images_prompt",
          { multiline: false }
        );
      }
    });
  });
</script>
